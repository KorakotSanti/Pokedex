{"version":3,"file":"router.d.ts","sources":["router.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Angular v10.1.1\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { AfterContentInit } from '@angular/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { Compiler } from '@angular/core';\nimport { ComponentFactoryResolver } from '@angular/core';\nimport { ComponentRef } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { HashLocationStrategy } from '@angular/common';\nimport { InjectionToken } from '@angular/core';\nimport { Injector } from '@angular/core';\nimport { Location } from '@angular/common';\nimport { LocationStrategy } from '@angular/common';\nimport { ModuleWithProviders } from '@angular/core';\nimport { NgModuleFactory } from '@angular/core';\nimport { NgModuleFactoryLoader } from '@angular/core';\nimport { NgProbeToken } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { PathLocationStrategy } from '@angular/common';\nimport { PlatformLocation } from '@angular/common';\nimport { Provider } from '@angular/core';\nimport { QueryList } from '@angular/core';\nimport { Renderer2 } from '@angular/core';\nimport { SimpleChanges } from '@angular/core';\nimport { Type } from '@angular/core';\nimport { Version } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\nimport { ViewportScroller } from '@angular/common';\n\n/**\n * Provides access to information about a route associated with a component\n * that is loaded in an outlet.\n * Use to traverse the `RouterState` tree and extract information from nodes.\n *\n * The following example shows how to construct a component using information from a\n * currently activated route.\n *\n * {@example router/activated-route/module.ts region=\"activated-route\"\n *     header=\"activated-route.component.ts\"}\n *\n * @see [Getting route information](guide/router#getting-route-information)\n *\n * @publicApi\n */\nexport declare class ActivatedRoute {\n    /** An observable of the URL segments matched by this route. */\n    url: Observable<UrlSegment[]>;\n    /** An observable of the matrix parameters scoped to this route. */\n    params: Observable<Params>;\n    /** An observable of the query parameters shared by all the routes. */\n    queryParams: Observable<Params>;\n    /** An observable of the URL fragment shared by all the routes. */\n    fragment: Observable<string>;\n    /** An observable of the static and resolved data of this route. */\n    data: Observable<Data>;\n    /** The outlet name of the route, a constant. */\n    outlet: string;\n    /** The component of the route, a constant. */\n    component: Type<any> | string | null;\n    /** The current snapshot of this route */\n    snapshot: ActivatedRouteSnapshot;\n    /** The configuration used to match this route. */\n    get routeConfig(): Route | null;\n    /** The root of the router state. */\n    get root(): ActivatedRoute;\n    /** The parent of this route in the router state tree. */\n    get parent(): ActivatedRoute | null;\n    /** The first child of this route in the router state tree. */\n    get firstChild(): ActivatedRoute | null;\n    /** The children of this route in the router state tree. */\n    get children(): ActivatedRoute[];\n    /** The path from the root of the router state tree to this route. */\n    get pathFromRoot(): ActivatedRoute[];\n    /**\n     * An Observable that contains a map of the required and optional parameters\n     * specific to the route.\n     * The map supports retrieving single and multiple values from the same parameter.\n     */\n    get paramMap(): Observable<ParamMap>;\n    /**\n     * An Observable that contains a map of the query parameters available to all routes.\n     * The map supports retrieving single and multiple values from the query parameter.\n     */\n    get queryParamMap(): Observable<ParamMap>;\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\n * traverse the router state tree.\n *\n * The following example initializes a component with route information extracted\n * from the snapshot of the root node at the time of creation.\n *\n * ```\n * @Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class ActivatedRouteSnapshot {\n    /** The URL segments matched by this route */\n    url: UrlSegment[];\n    /** The matrix parameters scoped to this route */\n    params: Params;\n    /** The query parameters shared by all the routes */\n    queryParams: Params;\n    /** The URL fragment shared by all the routes */\n    fragment: string;\n    /** The static and resolved data of this route */\n    data: Data;\n    /** The outlet name of the route */\n    outlet: string;\n    /** The component of the route */\n    component: Type<any> | string | null;\n    /** The configuration used to match this route **/\n    readonly routeConfig: Route | null;\n    /** The root of the router state */\n    get root(): ActivatedRouteSnapshot;\n    /** The parent of this route in the router state tree */\n    get parent(): ActivatedRouteSnapshot | null;\n    /** The first child of this route in the router state tree */\n    get firstChild(): ActivatedRouteSnapshot | null;\n    /** The children of this route in the router state tree */\n    get children(): ActivatedRouteSnapshot[];\n    /** The path from the root of the router state tree to this route */\n    get pathFromRoot(): ActivatedRouteSnapshot[];\n    get paramMap(): ParamMap;\n    get queryParamMap(): ParamMap;\n    toString(): string;\n}\n\n/**\n * An event triggered at the end of the activation part\n * of the Resolve phase of routing.\n * @see `ActivationStart`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport declare class ActivationEnd {\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot;\n    constructor(\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot);\n    toString(): string;\n}\n\n/**\n * An event triggered at the start of the activation part\n * of the Resolve phase of routing.\n * @see `ActivationEnd`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport declare class ActivationStart {\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot;\n    constructor(\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot);\n    toString(): string;\n}\n\n/**\n * @description\n *\n * This base route reuse strategy only reuses routes when the matched router configs are\n * identical. This prevents components from being destroyed and recreated\n * when just the fragment or query parameters change\n * (that is, the existing component is _reused_).\n *\n * This strategy does not store any routes for later reuse.\n *\n * Angular uses this strategy by default.\n *\n *\n * It can be used as a base class for custom route reuse strategies, i.e. you can create your own\n * class that extends the `BaseRouteReuseStrategy` one.\n * @publicApi\n */\nexport declare abstract class BaseRouteReuseStrategy implements RouteReuseStrategy {\n    /**\n     * Whether the given route should detach for later reuse.\n     * Always returns false for `BaseRouteReuseStrategy`.\n     * */\n    shouldDetach(route: ActivatedRouteSnapshot): boolean;\n    /**\n     * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\n     */\n    store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void;\n    /** Returns `false`, meaning the route (and its subtree) is never reattached */\n    shouldAttach(route: ActivatedRouteSnapshot): boolean;\n    /** Returns `null` because this strategy does not store routes for later re-use. */\n    retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;\n    /**\n     * Determines if a route should be reused.\n     * This strategy returns `true` when the future route config and current route config are\n     * identical.\n     */\n    shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;\n}\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a route can be activated.\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, the current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements a `CanActivate` function that checks whether the\n * current user has permission to activate the requested route.\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canActivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanActivateTeam implements CanActivate {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canActivate(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<boolean|UrlTree>|Promise<boolean|UrlTree>|boolean|UrlTree {\n *     return this.permissions.canActivate(this.currentUser, route.params.id);\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         canActivate: [CanActivateTeam]\n *       }\n *     ])\n *   ],\n *   providers: [CanActivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide an in-line function with the `canActivate` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         canActivate: ['canActivateTeam']\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'canActivateTeam',\n *       useValue: (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => true\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport declare interface CanActivate {\n    canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n}\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a child route can be activated.\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements a `CanActivateChild` function that checks whether the\n * current user has permission to activate the requested child route.\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canActivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanActivateTeam implements CanActivateChild {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canActivateChild(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<boolean|UrlTree>|Promise<boolean|UrlTree>|boolean|UrlTree {\n *     return this.permissions.canActivate(this.currentUser, route.params.id);\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'root',\n *         canActivateChild: [CanActivateTeam],\n *         children: [\n *           {\n *              path: 'team/:id',\n *              component: TeamComponent\n *           }\n *         ]\n *       }\n *     ])\n *   ],\n *   providers: [CanActivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide an in-line function with the `canActivateChild` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'root',\n *         canActivateChild: ['canActivateTeam'],\n *         children: [\n *           {\n *             path: 'team/:id',\n *             component: TeamComponent\n *           }\n *         ]\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'canActivateTeam',\n *       useValue: (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => true\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport declare interface CanActivateChild {\n    canActivateChild(childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n}\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a route can be deactivated.\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements a `CanDeactivate` function that checks whether the\n * current user has permission to deactivate the requested route.\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canDeactivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```\n *\n * @Injectable()\n * class CanDeactivateTeam implements CanDeactivate<TeamComponent> {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canDeactivate(\n *     component: TeamComponent,\n *     currentRoute: ActivatedRouteSnapshot,\n *     currentState: RouterStateSnapshot,\n *     nextState: RouterStateSnapshot\n *   ): Observable<boolean|UrlTree>|Promise<boolean|UrlTree>|boolean|UrlTree {\n *     return this.permissions.canDeactivate(this.currentUser, route.params.id);\n *   }\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         canDeactivate: [CanDeactivateTeam]\n *       }\n *     ])\n *   ],\n *   providers: [CanDeactivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide an in-line function with the `canDeactivate` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         canDeactivate: ['canDeactivateTeam']\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'canDeactivateTeam',\n *       useValue: (component: TeamComponent, currentRoute: ActivatedRouteSnapshot, currentState:\n * RouterStateSnapshot, nextState: RouterStateSnapshot) => true\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport declare interface CanDeactivate<T> {\n    canDeactivate(component: T, currentRoute: ActivatedRouteSnapshot, currentState: RouterStateSnapshot, nextState?: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n}\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if children can be loaded.\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\n * is cancelled and a new navigation starts to the `UrlTree` returned from the guard.\n *\n * The following example implements a `CanLoad` function that decides whether the\n * current user has permission to load requested child routes.\n *\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canLoadChildren(user: UserToken, id: string, segments: UrlSegment[]): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanLoadTeamSection implements CanLoad {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canLoad(route: Route, segments: UrlSegment[]): Observable<boolean>|Promise<boolean>|boolean {\n *     return this.permissions.canLoadChildren(this.currentUser, route, segments);\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         loadChildren: 'team.js',\n *         canLoad: [CanLoadTeamSection]\n *       }\n *     ])\n *   ],\n *   providers: [CanLoadTeamSection, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide an in-line function with the `canLoad` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         loadChildren: 'team.js',\n *         canLoad: ['canLoadTeamSection']\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'canLoadTeamSection',\n *       useValue: (route: Route, segments: UrlSegment[]) => true\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport declare interface CanLoad {\n    canLoad(route: Route, segments: UrlSegment[]): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n}\n\n/**\n * An event triggered at the end of the child-activation part\n * of the Resolve phase of routing.\n * @see `ChildActivationStart`\n * @see `ResolveStart`\n * @publicApi\n */\nexport declare class ChildActivationEnd {\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot;\n    constructor(\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot);\n    toString(): string;\n}\n\n/**\n * An event triggered at the start of the child-activation\n * part of the Resolve phase of routing.\n * @see  `ChildActivationEnd`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport declare class ChildActivationStart {\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot;\n    constructor(\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot);\n    toString(): string;\n}\n\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n * @publicApi\n */\nexport declare class ChildrenOutletContexts {\n    private contexts;\n    /** Called when a `RouterOutlet` directive is instantiated */\n    onChildOutletCreated(childName: string, outlet: RouterOutlet): void;\n    /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     */\n    onChildOutletDestroyed(childName: string): void;\n    /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     */\n    onOutletDeactivated(): Map<string, OutletContext>;\n    onOutletReAttached(contexts: Map<string, OutletContext>): void;\n    getOrCreateContext(childName: string): OutletContext;\n    getContext(childName: string): OutletContext | null;\n}\n\n/**\n * Converts a `Params` instance to a `ParamMap`.\n * @param params The instance to convert.\n * @returns The new map instance.\n *\n * @publicApi\n */\nexport declare function convertToParamMap(params: Params): ParamMap;\n\n/**\n *\n * Represents static data associated with a particular route.\n *\n * @see `Route#data`\n *\n * @publicApi\n */\nexport declare type Data = {\n    [name: string]: any;\n};\n\n/**\n * @description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * @publicApi\n */\nexport declare class DefaultUrlSerializer implements UrlSerializer {\n    /** Parses a url into a `UrlTree` */\n    parse(url: string): UrlTree;\n    /** Converts a `UrlTree` into a url */\n    serialize(tree: UrlTree): string;\n}\n\n/**\n * A string of the form `path/to/file#exportName` that acts as a URL for a set of routes to load.\n *\n * @see `loadChildrenCallback`\n * @publicApi\n * @deprecated The `string` form of `loadChildren` is deprecated in favor of the\n * `LoadChildrenCallback` function which uses the ES dynamic `import()` expression.\n * This offers a more natural and standards-based mechanism to dynamically\n * load an ES module at runtime.\n */\nexport declare type DeprecatedLoadChildren = string;\n\n/**\n * @description\n *\n * Represents the detached route tree.\n *\n * This is an opaque value the router will give to a custom route reuse strategy\n * to store and retrieve later on.\n *\n * @publicApi\n */\nexport declare type DetachedRouteHandle = {};\n\n/**\n * Error handler that is invoked when a navigation error occurs.\n *\n * If the handler returns a value, the navigation Promise is resolved with this value.\n * If the handler throws an exception, the navigation Promise is rejected with\n * the exception.\n *\n * @publicApi\n */\ndeclare type ErrorHandler = (error: any) => any;\n\n/**\n * Router events that allow you to track the lifecycle of the router.\n *\n * The events occur in the following sequence:\n *\n * * [NavigationStart](api/router/NavigationStart): Navigation starts.\n * * [RouteConfigLoadStart](api/router/RouteConfigLoadStart): Before\n * the router [lazy loads](/guide/router#lazy-loading) a route configuration.\n * * [RouteConfigLoadEnd](api/router/RouteConfigLoadEnd): After a route has been lazy loaded.\n * * [RoutesRecognized](api/router/RoutesRecognized): When the router parses the URL\n * and the routes are recognized.\n * * [GuardsCheckStart](api/router/GuardsCheckStart): When the router begins the *guards*\n * phase of routing.\n * * [ChildActivationStart](api/router/ChildActivationStart): When the router\n * begins activating a route's children.\n * * [ActivationStart](api/router/ActivationStart): When the router begins activating a route.\n * * [GuardsCheckEnd](api/router/GuardsCheckEnd): When the router finishes the *guards*\n * phase of routing successfully.\n * * [ResolveStart](api/router/ResolveStart): When the router begins the *resolve*\n * phase of routing.\n * * [ResolveEnd](api/router/ResolveEnd): When the router finishes the *resolve*\n * phase of routing successfuly.\n * * [ChildActivationEnd](api/router/ChildActivationEnd): When the router finishes\n * activating a route's children.\n * * [ActivationEnd](api/router/ActivationStart): When the router finishes activating a route.\n * * [NavigationEnd](api/router/NavigationEnd): When navigation ends successfully.\n * * [NavigationCancel](api/router/NavigationCancel): When navigation is canceled.\n * * [NavigationError](api/router/NavigationError): When navigation fails\n * due to an unexpected error.\n * * [Scroll](api/router/Scroll): When the user scrolls.\n *\n * @publicApi\n */\nexport declare type Event = RouterEvent | RouteConfigLoadStart | RouteConfigLoadEnd | ChildActivationStart | ChildActivationEnd | ActivationStart | ActivationEnd | Scroll;\n\n/**\n * A set of configuration options for a router module, provided in the\n * `forRoot()` method.\n *\n * @see `forRoot()`\n *\n *\n * @publicApi\n */\nexport declare interface ExtraOptions {\n    /**\n     * When true, log all internal navigation events to the console.\n     * Use for debugging.\n     */\n    enableTracing?: boolean;\n    /**\n     * When true, enable the location strategy that uses the URL fragment\n     * instead of the history API.\n     */\n    useHash?: boolean;\n    /**\n     * One of `enabled` or `disabled`.\n     * When set to `enabled`, the initial navigation starts before the root component is created.\n     * The bootstrap is blocked until the initial navigation is complete. This value is required for\n     * [server-side rendering](guide/universal) to work.\n     * When set to `disabled`, the initial navigation is not performed.\n     * The location listener is set up before the root component gets created.\n     * Use if there is a reason to have more control over when the router\n     * starts its initial navigation due to some complex initialization logic.\n     *\n     * Legacy values are deprecated since v4 and should not be used for new applications:\n     *\n     * * `legacy_enabled` - Default for compatibility.\n     * The initial navigation starts after the root component has been created,\n     * but the bootstrap is not blocked until the initial navigation is complete.\n     * * `legacy_disabled` - The initial navigation is not performed.\n     * The location listener is set up after the root component gets created.\n     * * `true` - same as `legacy_enabled`.\n     * * `false` - same as `legacy_disabled`.\n     */\n    initialNavigation?: InitialNavigation;\n    /**\n     * A custom error handler for failed navigations.\n     * If the handler returns a value, the navigation Promise is resolved with this value.\n     * If the handler throws an exception, the navigation Promise is rejected with the exception.\n     *\n     */\n    errorHandler?: ErrorHandler;\n    /**\n     * Configures a preloading strategy.\n     * One of `PreloadAllModules` or `NoPreloading` (the default).\n     */\n    preloadingStrategy?: any;\n    /**\n     * Define what the router should do if it receives a navigation request to the current URL.\n     * Default is `ignore`, which causes the router ignores the navigation.\n     * This can disable features such as a \"refresh\" button.\n     * Use this option to configure the behavior when navigating to the\n     * current URL. Default is 'ignore'.\n     */\n    onSameUrlNavigation?: 'reload' | 'ignore';\n    /**\n     * Configures if the scroll position needs to be restored when navigating back.\n     *\n     * * 'disabled'- (Default) Does nothing. Scroll position is maintained on navigation.\n     * * 'top'- Sets the scroll position to x = 0, y = 0 on all navigation.\n     * * 'enabled'- Restores the previous scroll position on backward navigation, else sets the\n     * position to the anchor if one is provided, or sets the scroll position to [0, 0] (forward\n     * navigation). This option will be the default in the future.\n     *\n     * You can implement custom scroll restoration behavior by adapting the enabled behavior as\n     * in the following example.\n     *\n     * ```typescript\n     * class AppModule {\n     *   constructor(router: Router, viewportScroller: ViewportScroller) {\n     *     router.events.pipe(\n     *       filter((e: Event): e is Scroll => e instanceof Scroll)\n     *     ).subscribe(e => {\n     *       if (e.position) {\n     *         // backward navigation\n     *         viewportScroller.scrollToPosition(e.position);\n     *       } else if (e.anchor) {\n     *         // anchor navigation\n     *         viewportScroller.scrollToAnchor(e.anchor);\n     *       } else {\n     *         // forward navigation\n     *         viewportScroller.scrollToPosition([0, 0]);\n     *       }\n     *     });\n     *   }\n     * }\n     * ```\n     */\n    scrollPositionRestoration?: 'disabled' | 'enabled' | 'top';\n    /**\n     * When set to 'enabled', scrolls to the anchor element when the URL has a fragment.\n     * Anchor scrolling is disabled by default.\n     *\n     * Anchor scrolling does not happen on 'popstate'. Instead, we restore the position\n     * that we stored or scroll to the top.\n     */\n    anchorScrolling?: 'disabled' | 'enabled';\n    /**\n     * Configures the scroll offset the router will use when scrolling to an element.\n     *\n     * When given a tuple with x and y position value,\n     * the router uses that offset each time it scrolls.\n     * When given a function, the router invokes the function every time\n     * it restores scroll position.\n     */\n    scrollOffset?: [number, number] | (() => [number, number]);\n    /**\n     * Defines how the router merges parameters, data, and resolved data from parent to child\n     * routes. By default ('emptyOnly'), inherits parent parameters only for\n     * path-less or component-less routes.\n     * Set to 'always' to enable unconditional inheritance of parent parameters.\n     */\n    paramsInheritanceStrategy?: 'emptyOnly' | 'always';\n    /**\n     * A custom handler for malformed URI errors. The handler is invoked when `encodedURI` contains\n     * invalid character sequences.\n     * The default implementation is to redirect to the root URL, dropping\n     * any path or parameter information. The function takes three parameters:\n     *\n     * - `'URIError'` - Error thrown when parsing a bad URL.\n     * - `'UrlSerializer'` - UrlSerializer thatâ€™s configured with the router.\n     * - `'url'` -  The malformed URL that caused the URIError\n     * */\n    malformedUriErrorHandler?: (error: URIError, urlSerializer: UrlSerializer, url: string) => UrlTree;\n    /**\n     * Defines when the router updates the browser URL. By default ('deferred'),\n     * update after successful navigation.\n     * Set to 'eager' if prefer to update the URL at the beginning of navigation.\n     * Updating the URL early allows you to handle a failure of navigation by\n     * showing an error message with the URL that failed.\n     */\n    urlUpdateStrategy?: 'deferred' | 'eager';\n    /**\n     * Enables a bug fix that corrects relative link resolution in components with empty paths.\n     * Example:\n     *\n     * ```\n     * const routes = [\n     *   {\n     *     path: '',\n     *     component: ContainerComponent,\n     *     children: [\n     *       { path: 'a', component: AComponent },\n     *       { path: 'b', component: BComponent },\n     *     ]\n     *   }\n     * ];\n     * ```\n     *\n     * From the `ContainerComponent`, this will not work:\n     *\n     * `<a [routerLink]=\"['./a']\">Link to A</a>`\n     *\n     * However, this will work:\n     *\n     * `<a [routerLink]=\"['../a']\">Link to A</a>`\n     *\n     * In other words, you're required to use `../` rather than `./`. This is currently the default\n     * behavior. Setting this option to `corrected` enables the fix.\n     */\n    relativeLinkResolution?: 'legacy' | 'corrected';\n}\n\n/**\n * An event triggered at the end of the Guard phase of routing.\n *\n * @see `GuardsCheckStart`\n *\n * @publicApi\n */\nexport declare class GuardsCheckEnd extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    /** @docsNotRequired */\n    state: RouterStateSnapshot;\n    /** @docsNotRequired */\n    shouldActivate: boolean;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string, \n    /** @docsNotRequired */\n    state: RouterStateSnapshot, \n    /** @docsNotRequired */\n    shouldActivate: boolean);\n    toString(): string;\n}\n\n/**\n * An event triggered at the start of the Guard phase of routing.\n *\n * @see `GuardsCheckEnd`\n *\n * @publicApi\n */\nexport declare class GuardsCheckStart extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    /** @docsNotRequired */\n    state: RouterStateSnapshot;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string, \n    /** @docsNotRequired */\n    state: RouterStateSnapshot);\n    toString(): string;\n}\n\n/**\n * Allowed values in an `ExtraOptions` object that configure\n * when the router performs the initial navigation operation.\n *\n * * 'enabled' - The initial navigation starts before the root component is created.\n * The bootstrap is blocked until the initial navigation is complete. This value is required\n * for [server-side rendering](guide/universal) to work.\n * * 'disabled' - The initial navigation is not performed. The location listener is set up before\n * the root component gets created. Use if there is a reason to have\n * more control over when the router starts its initial navigation due to some complex\n * initialization logic.\n *\n * The following values have been [deprecated](guide/releases#deprecation-practices) since v4,\n * and should not be used for new applications.\n *\n * * 'legacy_enabled'- (Default, for compatibility.) The initial navigation starts after the root\n * component has been created. The bootstrap is not blocked until the initial navigation is\n * complete.\n * * 'legacy_disabled'- The initial navigation is not performed. The location listener is set up\n * after the root component gets created.\n * * `true` - same as 'legacy_enabled'.\n * * `false` - same as 'legacy_disabled'.\n *\n * The 'legacy_enabled' and 'legacy_disabled' should not be used for new applications.\n *\n * @see `forRoot()`\n *\n * @publicApi\n */\nexport declare type InitialNavigation = true | false | 'enabled' | 'disabled' | 'legacy_enabled' | 'legacy_disabled';\n\n/**\n *\n * A function that returns a set of routes to load.\n *\n * The string form of `LoadChildren` is deprecated (see `DeprecatedLoadChildren`). The function\n * form (`LoadChildrenCallback`) should be used instead.\n *\n * @see `loadChildrenCallback`\n * @publicApi\n */\nexport declare type LoadChildren = LoadChildrenCallback | DeprecatedLoadChildren;\n\n/**\n *\n * A function that is called to resolve a collection of lazy-loaded routes.\n * Must be an arrow function of the following form:\n * `() => import('...').then(mod => mod.MODULE)`\n *\n * For example:\n *\n * ```\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),\n * }];\n * ```\n *\n * @see [Route.loadChildren](api/router/Route#loadChildren)\n * @publicApi\n */\nexport declare type LoadChildrenCallback = () => Type<any> | NgModuleFactory<any> | Observable<Type<any>> | Promise<NgModuleFactory<any> | Type<any> | any>;\n\n/**\n * Information about a navigation operation.\n * Retrieve the most recent navigation object with the\n * [Router.getCurrentNavigation() method](api/router/Router#getcurrentnavigation) .\n *\n * * *id* : The unique identifier of the current navigation.\n * * *initialUrl* : The target URL passed into the `Router#navigateByUrl()` call before navigation.\n * This is the value before the router has parsed or applied redirects to it.\n * * *extractedUrl* : The initial target URL after being parsed with `UrlSerializer.extract()`.\n * * *finalUrl* : The extracted URL after redirects have been applied.\n * This URL may not be available immediately, therefore this property can be `undefined`.\n * It is guaranteed to be set after the `RoutesRecognized` event fires.\n * * *trigger* : Identifies how this navigation was triggered.\n * -- 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\n * -- 'popstate'--Triggered by a popstate event.\n * -- 'hashchange'--Triggered by a hashchange event.\n * * *extras* : A `NavigationExtras` options object that controlled the strategy used for this\n * navigation.\n * * *previousNavigation* : The previously successful `Navigation` object. Only one previous\n * navigation is available, therefore this previous `Navigation` object has a `null` value for its\n * own `previousNavigation`.\n *\n * @publicApi\n */\nexport declare type Navigation = {\n    /**\n     * The unique identifier of the current navigation.\n     */\n    id: number;\n    /**\n     * The target URL passed into the `Router#navigateByUrl()` call before navigation. This is\n     * the value before the router has parsed or applied redirects to it.\n     */\n    initialUrl: string | UrlTree;\n    /**\n     * The initial target URL after being parsed with `UrlSerializer.extract()`.\n     */\n    extractedUrl: UrlTree;\n    /**\n     * The extracted URL after redirects have been applied.\n     * This URL may not be available immediately, therefore this property can be `undefined`.\n     * It is guaranteed to be set after the `RoutesRecognized` event fires.\n     */\n    finalUrl?: UrlTree;\n    /**\n     * Identifies how this navigation was triggered.\n     *\n     * * 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\n     * * 'popstate'--Triggered by a popstate event.\n     * * 'hashchange'--Triggered by a hashchange event.\n     */\n    trigger: 'imperative' | 'popstate' | 'hashchange';\n    /**\n     * Options that controlled the strategy used for this navigation.\n     * See `NavigationExtras`.\n     */\n    extras: NavigationExtras;\n    /**\n     * The previously successful `Navigation` object. Only one previous navigation\n     * is available, therefore this previous `Navigation` object has a `null` value\n     * for its own `previousNavigation`.\n     */\n    previousNavigation: Navigation | null;\n};\n\n/**\n * An event triggered when a navigation is canceled, directly or indirectly.\n * This can happen when a route guard\n * returns `false` or initiates a redirect by returning a `UrlTree`.\n *\n * @see `NavigationStart`\n * @see `NavigationEnd`\n * @see `NavigationError`\n *\n * @publicApi\n */\nexport declare class NavigationCancel extends RouterEvent {\n    /** @docsNotRequired */\n    reason: string;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    reason: string);\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * An event triggered when a navigation ends successfully.\n *\n * @see `NavigationStart`\n * @see `NavigationCancel`\n * @see `NavigationError`\n *\n * @publicApi\n */\nexport declare class NavigationEnd extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string);\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * An event triggered when a navigation fails due to an unexpected error.\n *\n * @see `NavigationStart`\n * @see `NavigationEnd`\n * @see `NavigationCancel`\n *\n * @publicApi\n */\nexport declare class NavigationError extends RouterEvent {\n    /** @docsNotRequired */\n    error: any;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    error: any);\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Options that modify the `Router` navigation strategy.\n * Supply an object containing any of these properties to a `Router` navigation function to\n * control how the target URL should be constructed or interpreted.\n *\n * @see [Router.navigate() method](api/router/Router#navigate)\n * @see [Router.navigateByUrl() method](api/router/Router#navigatebyurl)\n * @see [Router.createUrlTree() method](api/router/Router#createurltree)\n * @see [Routing and Navigation guide](guide/router)\n *\n * @publicApi\n */\nexport declare interface NavigationExtras {\n    /**\n     * Specifies a root URI to use for relative navigation.\n     *\n     * For example, consider the following route configuration where the parent route\n     * has two children.\n     *\n     * ```\n     * [{\n     *   path: 'parent',\n     *   component: ParentComponent,\n     *   children: [{\n     *     path: 'list',\n     *     component: ListComponent\n     *   },{\n     *     path: 'child',\n     *     component: ChildComponent\n     *   }]\n     * }]\n     * ```\n     *\n     * The following `go()` function navigates to the `list` route by\n     * interpreting the destination URI as relative to the activated `child`  route\n     *\n     * ```\n     *  @Component({...})\n     *  class ChildComponent {\n     *    constructor(private router: Router, private route: ActivatedRoute) {}\n     *\n     *    go() {\n     *      this.router.navigate(['../list'], { relativeTo: this.route });\n     *    }\n     *  }\n     * ```\n     */\n    relativeTo?: ActivatedRoute | null;\n    /**\n     * Sets query parameters to the URL.\n     *\n     * ```\n     * // Navigate to /results?page=1\n     * this.router.navigate(['/results'], { queryParams: { page: 1 } });\n     * ```\n     */\n    queryParams?: Params | null;\n    /**\n     * Sets the hash fragment for the URL.\n     *\n     * ```\n     * // Navigate to /results#top\n     * this.router.navigate(['/results'], { fragment: 'top' });\n     * ```\n     */\n    fragment?: string;\n    /**\n     * **DEPRECATED**: Use `queryParamsHandling: \"preserve\"` instead to preserve\n     * query parameters for the next navigation.\n     *\n     * @deprecated since v4\n     */\n    preserveQueryParams?: boolean;\n    /**\n     * How to handle query parameters in the router link for the next navigation.\n     * One of:\n     * * `preserve` : Preserve current parameters.\n     * * `merge` : Merge new with current parameters.\n     *\n     * The \"preserve\" option discards any new query params:\n     * ```\n     * // from /view1?page=1 to/view2?page=1\n     * this.router.navigate(['/view2'], { queryParams: { page: 2 },  queryParamsHandling: \"preserve\"\n     * });\n     * ```\n     * The \"merge\" option appends new query params to the params from the current URL:\n     * ```\n     * // from /view1?page=1 to/view2?page=1&otherKey=2\n     * this.router.navigate(['/view2'], { queryParams: { otherKey: 2 },  queryParamsHandling: \"merge\"\n     * });\n     * ```\n     * In case of a key collision between current parameters and those in the `queryParams` object,\n     * the new value is used.\n     *\n     */\n    queryParamsHandling?: QueryParamsHandling | null;\n    /**\n     * When true, preserves the URL fragment for the next navigation\n     *\n     * ```\n     * // Preserve fragment from /results#top to /view#top\n     * this.router.navigate(['/view'], { preserveFragment: true });\n     * ```\n     */\n    preserveFragment?: boolean;\n    /**\n     * When true, navigates without pushing a new state into history.\n     *\n     * ```\n     * // Navigate silently to /view\n     * this.router.navigate(['/view'], { skipLocationChange: true });\n     * ```\n     */\n    skipLocationChange?: boolean;\n    /**\n     * When true, navigates while replacing the current state in history.\n     *\n     * ```\n     * // Navigate to /view\n     * this.router.navigate(['/view'], { replaceUrl: true });\n     * ```\n     */\n    replaceUrl?: boolean;\n    /**\n     * Developer-defined state that can be passed to any navigation.\n     * Access this value through the `Navigation.extras` object\n     * returned from the [Router.getCurrentNavigation()\n     * method](api/router/Router#getcurrentnavigation) while a navigation is executing.\n     *\n     * After a navigation completes, the router writes an object containing this\n     * value together with a `navigationId` to `history.state`.\n     * The value is written when `location.go()` or `location.replaceState()`\n     * is called before activating this route.\n     *\n     * Note that `history.state` does not pass an object equality test because\n     * the router adds the `navigationId` on each navigation.\n     *\n     */\n    state?: {\n        [k: string]: any;\n    };\n}\n\n/**\n * An event triggered when a navigation starts.\n *\n * @publicApi\n */\nexport declare class NavigationStart extends RouterEvent {\n    /**\n     * Identifies the call or event that triggered the navigation.\n     * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\n     *\n     * @see `NavigationEnd`\n     * @see `NavigationCancel`\n     * @see `NavigationError`\n     */\n    navigationTrigger?: 'imperative' | 'popstate' | 'hashchange';\n    /**\n     * The navigation state that was previously supplied to the `pushState` call,\n     * when the navigation is triggered by a `popstate` event. Otherwise null.\n     *\n     * The state object is defined by `NavigationExtras`, and contains any\n     * developer-defined state value, as well as a unique ID that\n     * the router assigns to every router transition/navigation.\n     *\n     * From the perspective of the router, the router never \"goes back\".\n     * When the user clicks on the back button in the browser,\n     * a new navigation ID is created.\n     *\n     * Use the ID in this previous-state object to differentiate between a newly created\n     * state and one returned to by a `popstate` event, so that you can restore some\n     * remembered state, such as scroll position.\n     *\n     */\n    restoredState?: {\n        [k: string]: any;\n        navigationId: number;\n    } | null;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    navigationTrigger?: 'imperative' | 'popstate' | 'hashchange', \n    /** @docsNotRequired */\n    restoredState?: {\n        [k: string]: any;\n        navigationId: number;\n    } | null);\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Provides a preloading strategy that does not preload any modules.\n *\n * This strategy is enabled by default.\n *\n * @publicApi\n */\nexport declare class NoPreloading implements PreloadingStrategy {\n    preload(route: Route, fn: () => Observable<any>): Observable<any>;\n}\n\n/**\n * Store contextual information about a `RouterOutlet`\n *\n * @publicApi\n */\nexport declare class OutletContext {\n    outlet: RouterOutlet | null;\n    route: ActivatedRoute | null;\n    resolver: ComponentFactoryResolver | null;\n    children: ChildrenOutletContexts;\n    attachRef: ComponentRef<any> | null;\n}\n\n/**\n * A map that provides access to the required and optional parameters\n * specific to a route.\n * The map supports retrieving a single value with `get()`\n * or multiple values with `getAll()`.\n *\n * @see [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)\n *\n * @publicApi\n */\nexport declare interface ParamMap {\n    /**\n     * Reports whether the map contains a given parameter.\n     * @param name The parameter name.\n     * @returns True if the map contains the given parameter, false otherwise.\n     */\n    has(name: string): boolean;\n    /**\n     * Retrieves a single value for a parameter.\n     * @param name The parameter name.\n     * @return The parameter's single value,\n     * or the first value if the parameter has multiple values,\n     * or `null` when there is no such parameter.\n     */\n    get(name: string): string | null;\n    /**\n     * Retrieves multiple values for a parameter.\n     * @param name The parameter name.\n     * @return An array containing one or more values,\n     * or an empty array if there is no such parameter.\n     *\n     */\n    getAll(name: string): string[];\n    /** Names of the parameters in the map. */\n    readonly keys: string[];\n}\n\n/**\n * A collection of matrix and query URL parameters.\n * @see `convertToParamMap()`\n * @see `ParamMap`\n *\n * @publicApi\n */\nexport declare type Params = {\n    [key: string]: any;\n};\n\n/**\n * @description\n *\n * Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * ```\n * RouterModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * @publicApi\n */\nexport declare class PreloadAllModules implements PreloadingStrategy {\n    preload(route: Route, fn: () => Observable<any>): Observable<any>;\n}\n\n/**\n * @description\n *\n * Provides a preloading strategy.\n *\n * @publicApi\n */\nexport declare abstract class PreloadingStrategy {\n    abstract preload(route: Route, fn: () => Observable<any>): Observable<any>;\n}\n\n/**\n * The primary routing outlet.\n *\n * @publicApi\n */\nexport declare const PRIMARY_OUTLET = \"primary\";\n\n/**\n * Registers a [DI provider](guide/glossary#provider) for a set of routes.\n * @param routes The route configuration to provide.\n *\n * @usageNotes\n *\n * ```\n * @NgModule({\n *   imports: [RouterModule.forChild(ROUTES)],\n *   providers: [provideRoutes(EXTRA_ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * @publicApi\n */\nexport declare function provideRoutes(routes: Routes): any;\n\n/**\n *\n * How to handle query parameters in a router link.\n * One of:\n * - `merge` : Merge new with current parameters.\n * - `preserve` : Preserve current parameters.\n *\n * @see `NavigationExtras#queryParamsHandling`\n * @see `RouterLink`\n * @publicApi\n */\nexport declare type QueryParamsHandling = 'merge' | 'preserve' | '';\n\n/**\n * @description\n *\n * Interface that classes can implement to be a data provider.\n * A data provider class can be used with the router to resolve data during navigation.\n * The interface defines a `resolve()` method that is invoked when the navigation starts.\n * The router waits for the data to be resolved before the route is finally activated.\n *\n * The following example implements a `resolve()` method that retrieves the data\n * needed to activate the requested route.\n *\n * ```\n * @Injectable({ providedIn: 'root' })\n * export class HeroResolver implements Resolve<Hero> {\n *   constructor(private service: HeroService) {}\n *\n *   resolve(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<any>|Promise<any>|any {\n *     return this.service.getHero(route.paramMap.get('id'));\n *   }\n * }\n * ```\n *\n * Here, the defined `resolve()` function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```\n\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'detail/:id',\n *         component: HeroDetailComponent,\n *         resolve: {\n *           hero: HeroResolver\n *         }\n *       }\n *     ])\n *   ],\n *   exports: [RouterModule]\n * })\n * export class AppRoutingModule {}\n * ```\n *\n * You can alternatively provide an in-line function with the `resolve()` signature:\n *\n * ```\n * export const myHero: Hero = {\n *   // ...\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'detail/:id',\n *         component: HeroComponent,\n *         resolve: {\n *           hero: 'heroResolver'\n *         }\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'heroResolver',\n *       useValue: (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => myHero\n *     }\n *   ]\n * })\n * export class AppModule {}\n * ```\n *\n * @usageNotes\n *\n * When both guard and resolvers are specified, the resolvers are not executed until\n * all guards have run and succeeded.\n * For example, consider the following route configuration:\n *\n * ```\n * {\n *  path: 'base'\n *  canActivate: [BaseGuard],\n *  resolve: {data: BaseDataResolver}\n *  children: [\n *   {\n *     path: 'child',\n *     guards: [ChildGuard],\n *     component: ChildComponent,\n *     resolve: {childData: ChildDataResolver}\n *    }\n *  ]\n * }\n * ```\n * The order of execution is: BaseGuard, ChildGuard, BaseDataResolver, ChildDataResolver.\n *\n * @publicApi\n */\nexport declare interface Resolve<T> {\n    resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<T> | Promise<T> | T;\n}\n\n/**\n *\n * Represents the resolved data associated with a particular route.\n *\n * @see `Route#resolve`.\n *\n * @publicApi\n */\nexport declare type ResolveData = {\n    [name: string]: any;\n};\n\n/**\n * An event triggered at the end of the Resolve phase of routing.\n * @see `ResolveStart`.\n *\n * @publicApi\n */\nexport declare class ResolveEnd extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    /** @docsNotRequired */\n    state: RouterStateSnapshot;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string, \n    /** @docsNotRequired */\n    state: RouterStateSnapshot);\n    toString(): string;\n}\n\n/**\n * An event triggered at the the start of the Resolve phase of routing.\n *\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\n * In future, may change to only run when there are things to be resolved.\n *\n * @see `ResolveEnd`\n *\n * @publicApi\n */\nexport declare class ResolveStart extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    /** @docsNotRequired */\n    state: RouterStateSnapshot;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string, \n    /** @docsNotRequired */\n    state: RouterStateSnapshot);\n    toString(): string;\n}\n\n/**\n * A configuration object that defines a single route.\n * A set of routes are collected in a `Routes` array to define a `Router` configuration.\n * The router attempts to match segments of a given URL against each route,\n * using the configuration options defined in this object.\n *\n * Supports static, parameterized, redirect, and wildcard routes, as well as\n * custom route data and resolve methods.\n *\n * For detailed usage information, see the [Routing Guide](guide/router).\n *\n * @usageNotes\n *\n * ### Simple Configuration\n *\n * The following route specifies that when navigating to, for example,\n * `/team/11/user/bob`, the router creates the 'Team' component\n * with the 'User' child component in it.\n *\n * ```\n * [{\n *   path: 'team/:id',\n  *  component: Team,\n *   children: [{\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * ### Multiple Outlets\n *\n * The following route creates sibling components with multiple outlets.\n * When navigating to `/team/11(aux:chat/jim)`, the router creates the 'Team' component next to\n * the 'Chat' component. The 'Chat' component is placed into the 'aux' outlet.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team\n * }, {\n *   path: 'chat/:user',\n *   component: Chat\n *   outlet: 'aux'\n * }]\n * ```\n *\n * ### Wild Cards\n *\n * The following route uses wild-card notation to specify a component\n * that is always instantiated regardless of where you navigate to.\n *\n * ```\n * [{\n *   path: '**',\n *   component: WildcardComponent\n * }]\n * ```\n *\n * ### Redirects\n *\n * The following route uses the `redirectTo` property to ignore a segment of\n * a given URL when looking for a child path.\n *\n * When navigating to '/team/11/legacy/user/jim', the router changes the URL segment\n * '/team/11/legacy/user/jim' to '/team/11/user/jim', and then instantiates\n * the Team component with the User child component in it.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: 'legacy/user/:name',\n *     redirectTo: 'user/:name'\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * The redirect path can be relative, as shown in this example, or absolute.\n * If we change the `redirectTo` value in the example to the absolute URL segment '/user/:name',\n * the result URL is also absolute, '/user/jim'.\n\n * ### Empty Path\n *\n * Empty-path route configurations can be used to instantiate components that do not 'consume'\n * any URL segments.\n *\n * In the following configuration, when navigating to\n * `/team/11`, the router instantiates the 'AllUsers' component.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: AllUsers\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * Empty-path routes can have children. In the following example, when navigating\n * to `/team/11/user/jim`, the router instantiates the wrapper component with\n * the user component in it.\n *\n * Note that an empty path route inherits its parent's parameters and data.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: WrapperCmp,\n *     children: [{\n *       path: 'user/:name',\n *       component: User\n *     }]\n *   }]\n * }]\n * ```\n *\n * ### Matching Strategy\n *\n * The default path-match strategy is 'prefix', which means that the router\n * checks URL elements from the left to see if the URL matches a specified path.\n * For example, '/team/11/user' matches 'team/:id'.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'prefix', //default\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * You can specify the path-match strategy 'full' to make sure that the path\n * covers the whole unconsumed URL. It is important to do this when redirecting\n * empty-path routes. Otherwise, because an empty path is a prefix of any URL,\n * the router would apply the redirect even when navigating to the redirect destination,\n * creating an endless loop.\n *\n * In the following example, supplying the 'full' `pathMatch` strategy ensures\n * that the router applies the redirect if and only if navigating to '/'.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'full',\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * ### Componentless Routes\n *\n * You can share parameters between sibling components.\n * For example, suppose that two sibling components should go next to each other,\n * and both of them require an ID parameter. You can accomplish this using a route\n * that does not specify a component at the top level.\n *\n * In the following example, 'MainChild' and 'AuxChild' are siblings.\n * When navigating to 'parent/10/(a//aux:b)', the route instantiates\n * the main child and aux child components next to each other.\n * For this to work, the application component must have the primary and aux outlets defined.\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: 'a', component: MainChild },\n *      { path: 'b', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * The router merges the parameters, data, and resolve of the componentless\n * parent into the parameters, data, and resolve of the children.\n *\n * This is especially useful when child components are defined\n * with an empty path string, as in the following example.\n * With this configuration, navigating to '/parent/10' creates\n * the main child and aux components.\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: '', component: MainChild },\n *      { path: '', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * ### Lazy Loading\n *\n * Lazy loading speeds up application load time by splitting the application\n * into multiple bundles and loading them on demand.\n * To use lazy loading, provide the `loadChildren` property in the `Route` object,\n * instead of the `children` property.\n *\n * Given the following example route, the router will lazy load\n * the associated module on demand using the browser native import system.\n *\n * ```\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),\n * }];\n * ```\n *\n * @publicApi\n */\nexport declare interface Route {\n    /**\n     * The path to match against. Cannot be used together with a custom `matcher` function.\n     * A URL string that uses router matching notation.\n     * Can be a wild card (`**`) that matches any URL (see Usage Notes below).\n     * Default is \"/\" (the root path).\n     *\n     */\n    path?: string;\n    /**\n     * The path-matching strategy, one of 'prefix' or 'full'.\n     * Default is 'prefix'.\n     *\n     * By default, the router checks URL elements from the left to see if the URL\n     * matches a given  path, and stops when there is a match. For example,\n     * '/team/11/user' matches 'team/:id'.\n     *\n     * The path-match strategy 'full' matches against the entire URL.\n     * It is important to do this when redirecting empty-path routes.\n     * Otherwise, because an empty path is a prefix of any URL,\n     * the router would apply the redirect even when navigating\n     * to the redirect destination, creating an endless loop.\n     *\n     */\n    pathMatch?: string;\n    /**\n     * A custom URL-matching function. Cannot be used together with `path`.\n     */\n    matcher?: UrlMatcher;\n    /**\n     * The component to instantiate when the path matches.\n     * Can be empty if child routes specify components.\n     */\n    component?: Type<any>;\n    /**\n     * A URL to redirect to when the path matches.\n     * Absolute if the URL begins with a slash (/), otherwise relative to the path URL.\n     * When not present, router does not redirect.\n     */\n    redirectTo?: string;\n    /**\n     * Name of a `RouterOutlet` object where the component can be placed\n     * when the path matches.\n     */\n    outlet?: string;\n    /**\n     * An array of dependency-injection tokens used to look up `CanActivate()`\n     * handlers, in order to determine if the current user is allowed to\n     * activate the component. By default, any user can activate.\n     */\n    canActivate?: any[];\n    /**\n     * An array of DI tokens used to look up `CanActivateChild()` handlers,\n     * in order to determine if the current user is allowed to activate\n     * a child of the component. By default, any user can activate a child.\n     */\n    canActivateChild?: any[];\n    /**\n     * An array of DI tokens used to look up `CanDeactivate()`\n     * handlers, in order to determine if the current user is allowed to\n     * deactivate the component. By default, any user can deactivate.\n     *\n     */\n    canDeactivate?: any[];\n    /**\n     * An array of DI tokens used to look up `CanLoad()`\n     * handlers, in order to determine if the current user is allowed to\n     * load the component. By default, any user can load.\n     */\n    canLoad?: any[];\n    /**\n     * Additional developer-defined data provided to the component via\n     * `ActivatedRoute`. By default, no additional data is passed.\n     */\n    data?: Data;\n    /**\n     * A map of DI tokens used to look up data resolvers. See `Resolve`.\n     */\n    resolve?: ResolveData;\n    /**\n     * An array of child `Route` objects that specifies a nested route\n     * configuration.\n     */\n    children?: Routes;\n    /**\n     * An object specifying lazy-loaded child routes.\n     */\n    loadChildren?: LoadChildren;\n    /**\n     * Defines when guards and resolvers will be run. One of\n     * - `paramsOrQueryParamsChange` : Run when query parameters change.\n     * - `always` : Run on every execution.\n     * By default, guards and resolvers run only when the matrix\n     * parameters of the route change.\n     */\n    runGuardsAndResolvers?: RunGuardsAndResolvers;\n}\n\n/**\n * An event triggered when a route has been lazy loaded.\n *\n * @see `RouteConfigLoadStart`\n *\n * @publicApi\n */\nexport declare class RouteConfigLoadEnd {\n    /** @docsNotRequired */\n    route: Route;\n    constructor(\n    /** @docsNotRequired */\n    route: Route);\n    toString(): string;\n}\n\n/**\n * An event triggered before lazy loading a route configuration.\n *\n * @see `RouteConfigLoadEnd`\n *\n * @publicApi\n */\nexport declare class RouteConfigLoadStart {\n    /** @docsNotRequired */\n    route: Route;\n    constructor(\n    /** @docsNotRequired */\n    route: Route);\n    toString(): string;\n}\n\n/**\n * @description\n *\n * A service that provides navigation among views and URL manipulation capabilities.\n *\n * @see `Route`.\n * @see [Routing and Navigation Guide](guide/router).\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nexport declare class Router {\n    private rootComponentType;\n    private urlSerializer;\n    private rootContexts;\n    private location;\n    config: Routes;\n    private currentUrlTree;\n    private rawUrlTree;\n    private browserUrlTree;\n    private readonly transitions;\n    private navigations;\n    private lastSuccessfulNavigation;\n    private currentNavigation;\n    private locationSubscription?;\n    /**\n     * Tracks the previously seen location change from the location subscription so we can compare\n     * the two latest to see if they are duplicates. See setUpLocationChangeListener.\n     */\n    private lastLocationChangeInfo;\n    private navigationId;\n    private configLoader;\n    private ngModule;\n    private console;\n    private isNgZoneEnabled;\n    /**\n     * An event stream for routing events in this NgModule.\n     */\n    readonly events: Observable<Event>;\n    /**\n     * The current state of routing in this NgModule.\n     */\n    readonly routerState: RouterState;\n    /**\n     * A handler for navigation errors in this NgModule.\n     */\n    errorHandler: ErrorHandler;\n    /**\n     * A handler for errors thrown by `Router.parseUrl(url)`\n     * when `url` contains an invalid character.\n     * The most common case is a `%` sign\n     * that's not encoded and is not part of a percent encoded sequence.\n     */\n    malformedUriErrorHandler: (error: URIError, urlSerializer: UrlSerializer, url: string) => UrlTree;\n    /**\n     * True if at least one navigation event has occurred,\n     * false otherwise.\n     */\n    navigated: boolean;\n    private lastSuccessfulId;\n    /**\n     * A strategy for extracting and merging URLs.\n     * Used for AngularJS to Angular migrations.\n     */\n    urlHandlingStrategy: UrlHandlingStrategy;\n    /**\n     * A strategy for re-using routes.\n     */\n    routeReuseStrategy: RouteReuseStrategy;\n    /**\n     * How to handle a navigation request to the current URL. One of:\n     * - `'ignore'` :  The router ignores the request.\n     * - `'reload'` : The router reloads the URL. Use to implement a \"refresh\" feature.\n     */\n    onSameUrlNavigation: 'reload' | 'ignore';\n    /**\n     * How to merge parameters, data, and resolved data from parent to child\n     * routes. One of:\n     *\n     * - `'emptyOnly'` : Inherit parent parameters, data, and resolved data\n     * for path-less or component-less routes.\n     * - `'always'` : Inherit parent parameters, data, and resolved data\n     * for all child routes.\n     */\n    paramsInheritanceStrategy: 'emptyOnly' | 'always';\n    /**\n     * Determines when the router updates the browser URL.\n     * By default (`\"deferred\"`), updates the browser URL after navigation has finished.\n     * Set to `'eager'` to update the browser URL at the beginning of navigation.\n     * You can choose to update early so that, if navigation fails,\n     * you can show an error message with the URL that failed.\n     */\n    urlUpdateStrategy: 'deferred' | 'eager';\n    /**\n     * Enables a bug fix that corrects relative link resolution in components with empty paths.\n     * @see `RouterModule`\n     */\n    relativeLinkResolution: 'legacy' | 'corrected';\n    /**\n     * Creates the router service.\n     */\n    constructor(rootComponentType: Type<any> | null, urlSerializer: UrlSerializer, rootContexts: ChildrenOutletContexts, location: Location, injector: Injector, loader: NgModuleFactoryLoader, compiler: Compiler, config: Routes);\n    private setupNavigations;\n    private getTransition;\n    private setTransition;\n    /**\n     * Sets up the location change listener and performs the initial navigation.\n     */\n    initialNavigation(): void;\n    /**\n     * Sets up the location change listener. This listener detects navigations triggered from outside\n     * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router\n     * navigation so that the correct events, guards, etc. are triggered.\n     */\n    setUpLocationChangeListener(): void;\n    /** Extracts router-related information from a `PopStateEvent`. */\n    private extractLocationChangeInfoFromEvent;\n    /**\n     * Determines whether two events triggered by the Location subscription are due to the same\n     * navigation. The location subscription can fire two events (popstate and hashchange) for a\n     * single navigation. The second one should be ignored, that is, we should not schedule another\n     * navigation in the Router.\n     */\n    private shouldScheduleNavigation;\n    /** The current URL. */\n    get url(): string;\n    /** The current Navigation object if one exists */\n    getCurrentNavigation(): Navigation | null;\n    /**\n     * Resets the route configuration used for navigation and generating links.\n     *\n     * @param config The route array for the new configuration.\n     *\n     * @usageNotes\n     *\n     * ```\n     * router.resetConfig([\n     *  { path: 'team/:id', component: TeamCmp, children: [\n     *    { path: 'simple', component: SimpleCmp },\n     *    { path: 'user/:name', component: UserCmp }\n     *  ]}\n     * ]);\n     * ```\n     */\n    resetConfig(config: Routes): void;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    /** Disposes of the router. */\n    dispose(): void;\n    /**\n     * Appends URL segments to the current URL tree to create a new URL tree.\n     *\n     * @param commands An array of URL fragments with which to construct the new URL tree.\n     * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n     * segments, followed by the parameters for each segment.\n     * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`\n     * property of the options object, if supplied.\n     * @param navigationExtras Options that control the navigation strategy. This function\n     * only uses properties in `NavigationExtras` that would change the provided URL.\n     * @returns The new URL tree.\n     *\n     * @usageNotes\n     *\n     * ```\n     * // create /team/33/user/11\n     * router.createUrlTree(['/team', 33, 'user', 11]);\n     *\n     * // create /team/33;expand=true/user/11\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n     *\n     * // you can collapse static segments like this (this works only with the first passed-in value):\n     * router.createUrlTree(['/team/33/user', userId]);\n     *\n     * // If the first segment can contain slashes, and you do not want the router to split it,\n     * // you can do the following:\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\n     *\n     * // create /team/33/(user/11//right:chat)\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n     *\n     * // remove the right secondary node\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n     *\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n     *\n     * // navigate to /team/33/user/11/details\n     * router.createUrlTree(['details'], {relativeTo: route});\n     *\n     * // navigate to /team/33/user/22\n     * router.createUrlTree(['../22'], {relativeTo: route});\n     *\n     * // navigate to /team/44/user/22\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n     * ```\n     */\n    createUrlTree(commands: any[], navigationExtras?: NavigationExtras): UrlTree;\n    /**\n     * Navigates to a view using an absolute route path.\n     *\n     * @param url An absolute path for a defined route. The function does not apply any delta to the\n     *     current URL.\n     * @param extras An object containing properties that modify the navigation strategy.\n     * The function ignores any properties in the `NavigationExtras` that would change the\n     * provided URL.\n     *\n     * @returns A Promise that resolves to 'true' when navigation succeeds,\n     * to 'false' when navigation fails, or is rejected on error.\n     *\n     * @usageNotes\n     *\n     * The following calls request navigation to an absolute path.\n     *\n     * ```\n     * router.navigateByUrl(\"/team/33/user/11\");\n     *\n     * // Navigate without updating the URL\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n     * ```\n     *\n     * @see [Routing and Navigation guide](guide/router)\n     *\n     */\n    navigateByUrl(url: string | UrlTree, extras?: NavigationExtras): Promise<boolean>;\n    /**\n     * Navigate based on the provided array of commands and a starting point.\n     * If no starting route is provided, the navigation is absolute.\n     *\n     * @param commands An array of URL fragments with which to construct the target URL.\n     * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n     * segments, followed by the parameters for each segment.\n     * The fragments are applied to the current URL or the one provided  in the `relativeTo` property\n     * of the options object, if supplied.\n     * @param extras An options object that determines how the URL should be constructed or\n     *     interpreted.\n     *\n     * @returns A Promise that resolves to `true` when navigation succeeds, to `false` when navigation\n     *     fails,\n     * or is rejected on error.\n     *\n     * @usageNotes\n     *\n     * The following calls request navigation to a dynamic route path relative to the current URL.\n     *\n     * ```\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n     *\n     * // Navigate without updating the URL, overriding the default behavior\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n     * ```\n     *\n     * @see [Routing and Navigation guide](guide/router)\n     *\n     */\n    navigate(commands: any[], extras?: NavigationExtras): Promise<boolean>;\n    /** Serializes a `UrlTree` into a string */\n    serializeUrl(url: UrlTree): string;\n    /** Parses a string into a `UrlTree` */\n    parseUrl(url: string): UrlTree;\n    /** Returns whether the url is activated */\n    isActive(url: string | UrlTree, exact: boolean): boolean;\n    private removeEmptyProps;\n    private processNavigations;\n    private scheduleNavigation;\n    private setBrowserUrl;\n    private resetStateAndUrl;\n    private resetUrlToCurrentUrlTree;\n}\n\n/**\n * A [DI token](guide/glossary/#di-token) for the router service.\n *\n * @publicApi\n */\nexport declare const ROUTER_CONFIGURATION: InjectionToken<ExtraOptions>;\n\n/**\n * A [DI token](guide/glossary/#di-token) for the router initializer that\n * is called after the app is bootstrapped.\n *\n * @publicApi\n */\nexport declare const ROUTER_INITIALIZER: InjectionToken<(compRef: ComponentRef<any>) => void>;\n\n/**\n * @description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * @publicApi\n */\nexport declare abstract class RouteReuseStrategy {\n    /** Determines if this route (and its subtree) should be detached to be reused later */\n    abstract shouldDetach(route: ActivatedRouteSnapshot): boolean;\n    /**\n     * Stores the detached route.\n     *\n     * Storing a `null` value should erase the previously stored value.\n     */\n    abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void;\n    /** Determines if this route (and its subtree) should be reattached */\n    abstract shouldAttach(route: ActivatedRouteSnapshot): boolean;\n    /** Retrieves the previously stored route */\n    abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;\n    /** Determines if a route should be reused */\n    abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;\n}\n\n/**\n * Base for events the router goes through, as opposed to events tied to a specific\n * route. Fired one time for any given navigation.\n *\n * The following code shows how a class subscribes to router events.\n *\n * ```ts\n * class MyService {\n *   constructor(public router: Router, logger: Logger) {\n *     router.events.pipe(\n *        filter((e: Event): e is RouterEvent => e instanceof RouterEvent)\n *     ).subscribe((e: RouterEvent) => {\n *       logger.log(e.id, e.url);\n *     });\n *   }\n * }\n * ```\n *\n * @see `Event`\n * @see [Router events summary](guide/router#router-events)\n * @publicApi\n */\nexport declare class RouterEvent {\n    /** A unique ID that the router assigns to every router navigation. */\n    id: number;\n    /** The URL that is the destination for this navigation. */\n    url: string;\n    constructor(\n    /** A unique ID that the router assigns to every router navigation. */\n    id: number, \n    /** The URL that is the destination for this navigation. */\n    url: string);\n}\n\n/**\n * @description\n *\n * When applied to an element in a template, makes that element a link\n * that initiates navigation to a route. Navigation opens one or more routed components\n * in one or more `<router-outlet>` locations on the page.\n *\n * Given a route configuration `[{ path: 'user/:name', component: UserCmp }]`,\n * the following creates a static link to the route:\n * `<a routerLink=\"/user/bob\">link to user component</a>`\n *\n * You can use dynamic values to generate the link.\n * For a dynamic link, pass an array of path segments,\n * followed by the params for each segment.\n * For example, `['/team', teamId, 'user', userName, {details: true}]`\n * generates a link to `/team/11/user/bob;details=true`.\n *\n * Multiple static segments can be merged into one term and combined with dynamic segements.\n * For example, `['/team/11/user', userName, {details: true}]`\n *\n * The input that you provide to the link is treated as a delta to the current URL.\n * For instance, suppose the current URL is `/user/(box//aux:team)`.\n * The link `<a [routerLink]=\"['/user/jim']\">Jim</a>` creates the URL\n * `/user/(jim//aux:team)`.\n * See {@link Router#createUrlTree createUrlTree} for more information.\n *\n * @usageNotes\n *\n * You can use absolute or relative paths in a link, set query parameters,\n * control how parameters are handled, and keep a history of navigation states.\n *\n * ### Relative link paths\n *\n * The first segment name can be prepended with `/`, `./`, or `../`.\n * * If the first segment begins with `/`, the router looks up the route from the root of the\n *   app.\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router\n *   looks in the children of the current activated route.\n * * If the first segment begins with `../`, the router goes up one level in the route tree.\n *\n * ### Setting and handling query params and fragments\n *\n * The following link adds a query parameter and a fragment to the generated URL:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n *   link to user component\n * </a>\n * ```\n * By default, the directive constructs the new URL using the given query parameters.\n * The example generates the link: `/user/bob?debug=true#education`.\n *\n * You can instruct the directive to handle query parameters differently\n * by specifying the `queryParamsHandling` option in the link.\n * Allowed values are:\n *\n *  - `'merge'`: Merge the given `queryParams` into the current query params.\n *  - `'preserve'`: Preserve the current query params.\n *\n * For example:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\n *   link to user component\n * </a>\n * ```\n *\n * See {@link NavigationExtras.queryParamsHandling NavigationExtras#queryParamsHandling}.\n *\n * ### Preserving navigation history\n *\n * You can provide a `state` value to be persisted to the browser's\n * [`History.state` property](https://developer.mozilla.org/en-US/docs/Web/API/History#Properties).\n * For example:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [state]=\"{tracingId: 123}\">\n *   link to user component\n * </a>\n * ```\n *\n * Use {@link Router.getCurrentNavigation() Router#getCurrentNavigation} to retrieve a saved\n * navigation-state value. For example, to capture the `tracingId` during the `NavigationStart`\n * event:\n *\n * ```\n * // Get NavigationStart events\n * router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(e => {\n *   const navigation = router.getCurrentNavigation();\n *   tracingService.trace({id: navigation.extras.state.tracingId});\n * });\n * ```\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nexport declare class RouterLink implements OnChanges {\n    private router;\n    private route;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\n     * @see {@link NavigationExtras#queryParams NavigationExtras#queryParams}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    queryParams: {\n        [k: string]: any;\n    };\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\n     * @see {@link NavigationExtras#fragment NavigationExtras#fragment}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    fragment: string;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\n     * @see {@link NavigationExtras#queryParamsHandling NavigationExtras#queryParamsHandling}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    queryParamsHandling: QueryParamsHandling;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\n     * @see {@link NavigationExtras#preserveFragment NavigationExtras#preserveFragment}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    preserveFragment: boolean;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\n     * @see {@link NavigationExtras#skipLocationChange NavigationExtras#skipLocationChange}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    skipLocationChange: boolean;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\n     * @see {@link NavigationExtras#replaceUrl NavigationExtras#replaceUrl}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    replaceUrl: boolean;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\n     * @see {@link NavigationExtras#state NavigationExtras#state}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    state?: {\n        [k: string]: any;\n    };\n    private commands;\n    private preserve;\n    constructor(router: Router, route: ActivatedRoute, tabIndex: string, renderer: Renderer2, el: ElementRef);\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): void;\n    /**\n     * Commands to pass to {@link Router#createUrlTree Router#createUrlTree}.\n     *   - **array**: commands to pass to {@link Router#createUrlTree Router#createUrlTree}.\n     *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`\n     *   - **null|undefined**: shorthand for an empty array of commands, i.e. `[]`\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    set routerLink(commands: any[] | string | null | undefined);\n    /**\n     * @deprecated As of Angular v4.0 use `queryParamsHandling` instead.\n     */\n    set preserveQueryParams(value: boolean);\n    /** @nodoc */\n    onClick(): boolean;\n    get urlTree(): UrlTree;\n}\n\n/**\n *\n * @description\n *\n * Tracks whether the linked route of an element is currently active, and allows you\n * to specify one or more CSS classes to add to the element when the linked route\n * is active.\n *\n * Use this directive to create a visual distinction for elements associated with an active route.\n * For example, the following code highlights the word \"Bob\" when the the router\n * activates the associated route:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * Whenever the URL is either '/user' or '/user/bob', the \"active-link\" class is\n * added to the anchor tag. If the URL changes, the class is removed.\n *\n * You can set more than one class using a space-separated string or an array.\n * For example:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n * ```\n *\n * To add the classes only when the URL matches the link exactly, add the option `exact: true`:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n * true}\">Bob</a>\n * ```\n *\n * To directly check the `isActive` status of the link, assign the `RouterLinkActive`\n * instance to a template variable.\n * For example, the following checks the status without assigning any CSS classes:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\n * </a>\n * ```\n *\n * You can apply the `RouterLinkActive` directive to an ancestor of linked elements.\n * For example, the following sets the active-link class on the `<div>`  parent tag\n * when the URL is either '/user/jim' or '/user/bob'.\n *\n * ```\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n *   <a routerLink=\"/user/jim\">Jim</a>\n *   <a routerLink=\"/user/bob\">Bob</a>\n * </div>\n * ```\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nexport declare class RouterLinkActive implements OnChanges, OnDestroy, AfterContentInit {\n    private router;\n    private element;\n    private renderer;\n    private readonly cdr;\n    private link?;\n    private linkWithHref?;\n    links: QueryList<RouterLink>;\n    linksWithHrefs: QueryList<RouterLinkWithHref>;\n    private classes;\n    private routerEventsSubscription;\n    private linkInputChangesSubscription?;\n    readonly isActive: boolean;\n    routerLinkActiveOptions: {\n        exact: boolean;\n    };\n    constructor(router: Router, element: ElementRef, renderer: Renderer2, cdr: ChangeDetectorRef, link?: RouterLink | undefined, linkWithHref?: RouterLinkWithHref | undefined);\n    /** @nodoc */\n    ngAfterContentInit(): void;\n    private subscribeToEachLinkOnChanges;\n    set routerLinkActive(data: string[] | string);\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): void;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    private update;\n    private isLinkActive;\n    private hasActiveLinks;\n}\n\n/**\n * @description\n *\n * Lets you link to specific routes in your app.\n *\n * See `RouterLink` for more information.\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nexport declare class RouterLinkWithHref implements OnChanges, OnDestroy {\n    private router;\n    private route;\n    private locationStrategy;\n    target: string;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\n     * @see {@link NavigationExtras#queryParams NavigationExtras#queryParams}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    queryParams: {\n        [k: string]: any;\n    };\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\n     * @see {@link NavigationExtras#fragment NavigationExtras#fragment}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    fragment: string;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\n     * @see {@link NavigationExtras#queryParamsHandling NavigationExtras#queryParamsHandling}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    queryParamsHandling: QueryParamsHandling;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\n     * @see {@link NavigationExtras#preserveFragment NavigationExtras#preserveFragment}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    preserveFragment: boolean;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\n     * @see {@link NavigationExtras#skipLocationChange NavigationExtras#skipLocationChange}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    skipLocationChange: boolean;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\n     * @see {@link NavigationExtras#replaceUrl NavigationExtras#replaceUrl}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    replaceUrl: boolean;\n    /**\n     * Passed to {@link Router#createUrlTree Router#createUrlTree} as part of the `NavigationExtras`.\n     * @see {@link NavigationExtras#state NavigationExtras#state}\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    state?: {\n        [k: string]: any;\n    };\n    private commands;\n    private subscription;\n    private preserve;\n    href: string;\n    constructor(router: Router, route: ActivatedRoute, locationStrategy: LocationStrategy);\n    /**\n     * Commands to pass to {@link Router#createUrlTree Router#createUrlTree}.\n     *   - **array**: commands to pass to {@link Router#createUrlTree Router#createUrlTree}.\n     *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`\n     *   - **null|undefined**: shorthand for an empty array of commands, i.e. `[]`\n     * @see {@link Router#createUrlTree Router#createUrlTree}\n     */\n    set routerLink(commands: any[] | string | null | undefined);\n    /**\n     * @deprecated As of Angular v4.0 use `queryParamsHandling` instead.\n     */\n    set preserveQueryParams(value: boolean);\n    /** @nodoc */\n    ngOnChanges(changes: SimpleChanges): any;\n    /** @nodoc */\n    ngOnDestroy(): any;\n    /** @nodoc */\n    onClick(button: number, ctrlKey: boolean, shiftKey: boolean, altKey: boolean, metaKey: boolean): boolean;\n    private updateTargetUrlAndHref;\n    get urlTree(): UrlTree;\n}\n\n/**\n * @description\n *\n * Adds directives and providers for in-app navigation among views defined in an application.\n * Use the Angular `Router` service to declaratively specify application states and manage state\n * transitions.\n *\n * You can import this NgModule multiple times, once for each lazy-loaded bundle.\n * However, only one `Router` service can be active.\n * To ensure this, there are two ways to register routes when importing this module:\n *\n * * The `forRoot()` method creates an `NgModule` that contains all the directives, the given\n * routes, and the `Router` service itself.\n * * The `forChild()` method creates an `NgModule` that contains all the directives and the given\n * routes, but does not include the `Router` service.\n *\n * @see [Routing and Navigation guide](guide/router) for an\n * overview of how the `Router` service should be used.\n *\n * @publicApi\n */\nexport declare class RouterModule {\n    constructor(guard: any, router: Router);\n    /**\n     * Creates and configures a module with all the router providers and directives.\n     * Optionally sets up an application listener to perform an initial navigation.\n     *\n     * When registering the NgModule at the root, import as follows:\n     *\n     * ```\n     * @NgModule({\n     *   imports: [RouterModule.forRoot(ROUTES)]\n     * })\n     * class MyNgModule {}\n     * ```\n     *\n     * @param routes An array of `Route` objects that define the navigation paths for the application.\n     * @param config An `ExtraOptions` configuration object that controls how navigation is performed.\n     * @return The new `NgModule`.\n     *\n     */\n    static forRoot(routes: Routes, config?: ExtraOptions): ModuleWithProviders<RouterModule>;\n    /**\n     * Creates a module with all the router directives and a provider registering routes,\n     * without creating a new Router service.\n     * When registering for submodules and lazy-loaded submodules, create the NgModule as follows:\n     *\n     * ```\n     * @NgModule({\n     *   imports: [RouterModule.forChild(ROUTES)]\n     * })\n     * class MyNgModule {}\n     * ```\n     *\n     * @param routes An array of `Route` objects that define the navigation paths for the submodule.\n     * @return The new NgModule.\n     *\n     */\n    static forChild(routes: Routes): ModuleWithProviders<RouterModule>;\n}\n\n/**\n * @description\n *\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * Each outlet can have a unique name, determined by the optional `name` attribute.\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\n *\n * ```\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * Named outlets can be the targets of secondary routes.\n * The `Route` object for a secondary route has an `outlet` property to identify the target outlet:\n *\n * `{path: <base-path>, component: <component>, outlet: <target_outlet_name>}`\n *\n * Using named outlets and secondary routes, you can target multiple outlets in\n * the same `RouterLink` directive.\n *\n * The router keeps track of separate branches in a navigation tree for each named outlet and\n * generates a representation of that tree in the URL.\n * The URL for a secondary route uses the following syntax to specify both the primary and secondary\n * routes at the same time:\n *\n * `http://base-path/primary-route-path(outlet-name:route-path)`\n *\n * A router outlet emits an activate event when a new component is instantiated,\n * and a deactivate event when a component is destroyed.\n *\n * ```\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'></router-outlet>\n * ```\n *\n * @see [Routing tutorial](guide/router-tutorial-toh#named-outlets \"Example of a named\n * outlet and secondary route configuration\").\n * @see `RouterLink`\n * @see `Route`\n * @ngModule RouterModule\n *\n * @publicApi\n */\nexport declare class RouterOutlet implements OnDestroy, OnInit {\n    private parentContexts;\n    private location;\n    private resolver;\n    private changeDetector;\n    private activated;\n    private _activatedRoute;\n    private name;\n    activateEvents: EventEmitter<any>;\n    deactivateEvents: EventEmitter<any>;\n    constructor(parentContexts: ChildrenOutletContexts, location: ViewContainerRef, resolver: ComponentFactoryResolver, name: string, changeDetector: ChangeDetectorRef);\n    /** @nodoc */\n    ngOnDestroy(): void;\n    /** @nodoc */\n    ngOnInit(): void;\n    get isActivated(): boolean;\n    get component(): Object;\n    get activatedRoute(): ActivatedRoute;\n    get activatedRouteData(): Data;\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     */\n    detach(): ComponentRef<any>;\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     */\n    attach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute): void;\n    deactivate(): void;\n    activateWith(activatedRoute: ActivatedRoute, resolver: ComponentFactoryResolver | null): void;\n}\n\n/**\n * The preloader optimistically loads all router configurations to\n * make navigations into lazily-loaded sections of the application faster.\n *\n * The preloader runs in the background. When the router bootstraps, the preloader\n * starts listening to all navigation events. After every such event, the preloader\n * will check if any configurations can be loaded lazily.\n *\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\n *\n * @publicApi\n */\nexport declare class RouterPreloader implements OnDestroy {\n    private router;\n    private injector;\n    private preloadingStrategy;\n    private loader;\n    private subscription?;\n    constructor(router: Router, moduleLoader: NgModuleFactoryLoader, compiler: Compiler, injector: Injector, preloadingStrategy: PreloadingStrategy);\n    setUpPreloading(): void;\n    preload(): Observable<any>;\n    /** @nodoc */\n    ngOnDestroy(): void;\n    private processRoutes;\n    private preloadConfig;\n}\n\n/**\n * Represents the state of the router as a tree of activated routes.\n *\n * @usageNotes\n *\n * Every node in the route tree is an `ActivatedRoute` instance\n * that knows about the \"consumed\" URL segments, the extracted parameters,\n * and the resolved data.\n * Use the `ActivatedRoute` properties to traverse the tree from any node.\n *\n * The following fragment shows how a component gets the root node\n * of the current state to establish its own route tree:\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @see `ActivatedRoute`\n * @see [Getting route information](guide/router#getting-route-information)\n *\n * @publicApi\n */\nexport declare class RouterState extends Éµangular_packages_router_router_m<ActivatedRoute> {\n    /** The current snapshot of the router state */\n    snapshot: RouterStateSnapshot;\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * The following example shows how a component is initialized with information\n * from the snapshot of the root node's state at the time of creation.\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class RouterStateSnapshot extends Éµangular_packages_router_router_m<ActivatedRouteSnapshot> {\n    /** The url from which this snapshot was created */\n    url: string;\n    toString(): string;\n}\n\n/**\n * The [DI token](guide/glossary/#di-token) for a router configuration.\n * @see `ROUTES`\n * @publicApi\n */\nexport declare const ROUTES: InjectionToken<Route[][]>;\n\n/**\n * Represents a route configuration for the Router service.\n * An array of `Route` objects, used in `Router.config` and for nested route configurations\n * in `Route.children`.\n *\n * @see `Route`\n * @see `Router`\n * @see [Router configuration guide](guide/router#configuration)\n * @publicApi\n */\nexport declare type Routes = Route[];\n\n/**\n * An event triggered when routes are recognized.\n *\n * @publicApi\n */\nexport declare class RoutesRecognized extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    /** @docsNotRequired */\n    state: RouterStateSnapshot;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string, \n    /** @docsNotRequired */\n    state: RouterStateSnapshot);\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n *\n * A policy for when to run guards and resolvers on a route.\n *\n * @see [Route.runGuardsAndResolvers](api/router/Route#runGuardsAndResolvers)\n * @publicApi\n */\nexport declare type RunGuardsAndResolvers = 'pathParamsChange' | 'pathParamsOrQueryParamsChange' | 'paramsChange' | 'paramsOrQueryParamsChange' | 'always' | ((from: ActivatedRouteSnapshot, to: ActivatedRouteSnapshot) => boolean);\n\n/**\n * An event triggered by scrolling.\n *\n * @publicApi\n */\nexport declare class Scroll {\n    /** @docsNotRequired */\n    readonly routerEvent: NavigationEnd;\n    /** @docsNotRequired */\n    readonly position: [number, number] | null;\n    /** @docsNotRequired */\n    readonly anchor: string | null;\n    constructor(\n    /** @docsNotRequired */\n    routerEvent: NavigationEnd, \n    /** @docsNotRequired */\n    position: [number, number] | null, \n    /** @docsNotRequired */\n    anchor: string | null);\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * @publicApi\n */\nexport declare abstract class UrlHandlingStrategy {\n    /**\n     * Tells the router if this URL should be processed.\n     *\n     * When it returns true, the router will execute the regular navigation.\n     * When it returns false, the router will set the router state to an empty state.\n     * As a result, all the active components will be destroyed.\n     *\n     */\n    abstract shouldProcessUrl(url: UrlTree): boolean;\n    /**\n     * Extracts the part of the URL that should be handled by the router.\n     * The rest of the URL will remain untouched.\n     */\n    abstract extract(url: UrlTree): UrlTree;\n    /**\n     * Merges the URL fragment with the rest of the URL.\n     */\n    abstract merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree;\n}\n\n/**\n * A function for matching a route against URLs. Implement a custom URL matcher\n * for `Route.matcher` when a combination of `path` and `pathMatch`\n * is not expressive enough. Cannot be used together with `path` and `pathMatch`.\n *\n * The function takes the following arguments and returns a `UrlMatchResult` object.\n * * *segments* : An array of URL segments.\n * * *group* : A segment group.\n * * *route* : The route to match against.\n *\n * The following example implementation matches HTML files.\n *\n * ```\n * export function htmlFiles(url: UrlSegment[]) {\n *   return url.length === 1 && url[0].path.endsWith('.html') ? ({consumed: url}) : null;\n * }\n *\n * export const routes = [{ matcher: htmlFiles, component: AnyComponent }];\n * ```\n *\n * @publicApi\n */\nexport declare type UrlMatcher = (segments: UrlSegment[], group: UrlSegmentGroup, route: Route) => UrlMatchResult | null;\n\n/**\n * Represents the result of matching URLs with a custom matching function.\n *\n * * `consumed` is an array of the consumed URL segments.\n * * `posParams` is a map of positional parameters.\n *\n * @see `UrlMatcher()`\n * @publicApi\n */\nexport declare type UrlMatchResult = {\n    consumed: UrlSegment[];\n    posParams?: {\n        [name: string]: UrlSegment;\n    };\n};\n\n/**\n * @description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * @usageNotes\n *Â ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class UrlSegment {\n    /** The path part of a URL segment */\n    path: string;\n    /** The matrix parameters associated with a segment */\n    parameters: {\n        [name: string]: string;\n    };\n    constructor(\n    /** The path part of a URL segment */\n    path: string, \n    /** The matrix parameters associated with a segment */\n    parameters: {\n        [name: string]: string;\n    });\n    get parameterMap(): ParamMap;\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n * @publicApi\n */\nexport declare class UrlSegmentGroup {\n    /** The URL segments of this group. See `UrlSegment` for more information */\n    segments: UrlSegment[];\n    /** The list of children of this group */\n    children: {\n        [key: string]: UrlSegmentGroup;\n    };\n    /** The parent node in the url tree */\n    parent: UrlSegmentGroup | null;\n    constructor(\n    /** The URL segments of this group. See `UrlSegment` for more information */\n    segments: UrlSegment[], \n    /** The list of children of this group */\n    children: {\n        [key: string]: UrlSegmentGroup;\n    });\n    /** Whether the segment has child segments */\n    hasChildren(): boolean;\n    /** Number of child segments */\n    get numberOfChildren(): number;\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n * @publicApi\n */\nexport declare abstract class UrlSerializer {\n    /** Parse a url into a `UrlTree` */\n    abstract parse(url: string): UrlTree;\n    /** Converts a `UrlTree` into a url */\n    abstract serialize(tree: UrlTree): string;\n}\n\n/**\n * @description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class UrlTree {\n    /** The root segment group of the URL tree */\n    root: UrlSegmentGroup;\n    /** The query params of the URL */\n    queryParams: Params;\n    /** The fragment of the URL */\n    fragment: string | null;\n    get queryParamMap(): ParamMap;\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * @publicApi\n */\nexport declare const VERSION: Version;\n\n/**\n * @docsNotRequired\n */\nexport declare const Éµangular_packages_router_router_a: InjectionToken<void>;\n\nexport declare function Éµangular_packages_router_router_b(): NgProbeToken;\n\nexport declare function Éµangular_packages_router_router_c(router: Router, viewportScroller: ViewportScroller, config: ExtraOptions): Éµangular_packages_router_router_o;\n\nexport declare function Éµangular_packages_router_router_d(platformLocationStrategy: PlatformLocation, baseHref: string, options?: ExtraOptions): HashLocationStrategy | PathLocationStrategy;\n\nexport declare function Éµangular_packages_router_router_e(router: Router): any;\n\nexport declare function Éµangular_packages_router_router_f(urlSerializer: UrlSerializer, contexts: ChildrenOutletContexts, location: Location, injector: Injector, loader: NgModuleFactoryLoader, compiler: Compiler, config: Route[][], opts?: ExtraOptions, urlHandlingStrategy?: UrlHandlingStrategy, routeReuseStrategy?: RouteReuseStrategy): Router;\n\nexport declare function Éµangular_packages_router_router_g(router: Router): ActivatedRoute;\n\n/**\n * Router initialization requires two steps:\n *\n * First, we start the navigation in a `APP_INITIALIZER` to block the bootstrap if\n * a resolver or a guard executes asynchronously.\n *\n * Next, we actually run activation in a `BOOTSTRAP_LISTENER`, using the\n * `afterPreactivation` hook provided by the router.\n * The router navigation starts, reaches the point when preactivation is done, and then\n * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.\n */\nexport declare class Éµangular_packages_router_router_h {\n    private injector;\n    private initNavigation;\n    private resultOfPreactivationDone;\n    constructor(injector: Injector);\n    appInitializer(): Promise<any>;\n    bootstrapListener(bootstrappedComponentRef: ComponentRef<any>): void;\n    private isLegacyEnabled;\n    private isLegacyDisabled;\n}\n\nexport declare function Éµangular_packages_router_router_i(r: Éµangular_packages_router_router_h): () => Promise<any>;\n\nexport declare function Éµangular_packages_router_router_j(r: Éµangular_packages_router_router_h): (bootstrappedComponentRef: ComponentRef<any>) => void;\n\nexport declare function Éµangular_packages_router_router_k(): (typeof Éµangular_packages_router_router_h | {\n    provide: InjectionToken<(() => void)[]>;\n    multi: boolean;\n    useFactory: typeof Éµangular_packages_router_router_i;\n    deps: (typeof Éµangular_packages_router_router_h)[];\n    useExisting?: undefined;\n} | {\n    provide: InjectionToken<(compRef: ComponentRef<any>) => void>;\n    useFactory: typeof Éµangular_packages_router_router_j;\n    deps: (typeof Éµangular_packages_router_router_h)[];\n    multi?: undefined;\n    useExisting?: undefined;\n} | {\n    provide: InjectionToken<((compRef: ComponentRef<any>) => void)[]>;\n    multi: boolean;\n    useExisting: InjectionToken<(compRef: ComponentRef<any>) => void>;\n    useFactory?: undefined;\n    deps?: undefined;\n})[];\n\n\nexport declare class Éµangular_packages_router_router_m<T> {\n    constructor(root: Éµangular_packages_router_router_n<T>);\n    get root(): T;\n}\n\nexport declare class Éµangular_packages_router_router_n<T> {\n    value: T;\n    children: Éµangular_packages_router_router_n<T>[];\n    constructor(value: T, children: Éµangular_packages_router_router_n<T>[]);\n    toString(): string;\n}\n\nexport declare class Éµangular_packages_router_router_o implements OnDestroy {\n    private router;\n    /** @docsNotRequired */ readonly viewportScroller: ViewportScroller;\n    private options;\n    private routerEventsSubscription;\n    private scrollEventsSubscription;\n    private lastId;\n    private lastSource;\n    private restoredId;\n    private store;\n    constructor(router: Router, \n    /** @docsNotRequired */ viewportScroller: ViewportScroller, options?: {\n        scrollPositionRestoration?: 'disabled' | 'enabled' | 'top';\n        anchorScrolling?: 'disabled' | 'enabled';\n    });\n    init(): void;\n    private createScrollEvents;\n    private consumeScrollEvents;\n    private scheduleScrollEvent;\n    /** @nodoc */\n    ngOnDestroy(): void;\n}\n\n\n/**\n * This component is used internally within the router to be a placeholder when an empty\n * router-outlet is needed. For example, with a config such as:\n *\n * `{path: 'parent', outlet: 'nav', children: [...]}`\n *\n * In order to render, there needs to be a component on this config, which will default\n * to this `EmptyOutletComponent`.\n */\ndeclare class ÉµEmptyOutletComponent {\n}\nexport { ÉµEmptyOutletComponent }\nexport { ÉµEmptyOutletComponent as Éµangular_packages_router_router_l }\n\n/**\n * Flattens single-level nested arrays.\n */\nexport declare function Éµflatten<T>(arr: T[][]): T[];\n\nexport declare const ÉµROUTER_PROVIDERS: Provider[];\n\nexport { }\n"]}